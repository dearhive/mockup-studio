<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta id="viewport" name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

    <title>Mockup Studio : Create Unique PSD Free Mockups</title>
    <meta name="description" content="Create Mockups for Trifold, Bifold, Stationary, BusinessCard, UI, Flyers">
    <meta name="keywords" content="mockup studio, mockup, trifold, bifold">
    <meta name="google-signin-client_id" content="661814662202-cgn3p7lodc5b076rvsj0i57ssens9s24.apps.googleusercontent.com">
    <meta name="robots" content="index,follow">

    <link href="css/assets.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link href="css/libs/styles.css" rel="stylesheet">
    <link href="css/libs/sweetalert.css" rel="stylesheet">
    <link href="css/ionicons.css" rel="stylesheet" type="text/css">
    <link rel="icon" type="image/png" href="images/icon_16.png">
</head>
<body class="absolute-stretch">
<section id="webgl_notice" class="absolute-stretch">
    <h1>Create Unique Mockups for Trifold, Bifold, and more..</h1>
    Your browser doesn't support webGL properly.
    <br><br><br>
    <a id="extension_link" href="https://chrome.google.com/webstore/detail/mockup-studio-psd-free-so/gcmmimgfjaeohjmmdpmaimonepmlfbfi" target="_blank"  title="Get Chrome Extension">Get Chrome Extension</a>

    <!--<br>Please use <a        href="https://www.google.com/chrome/browser/desktop/">Google    Chrome</a> for best results.-->
</section>
<section id="chrome_notice" class="">MOCKUP Studio may not work best on this browser <br>Please use <a
        href="https://www.google.com/chrome/browser/desktop/">Google
    Chrome</a> for best results.
    <br><br>
    <a id="purchase_link" href="http://codecanyon.net/item/mockup-studio-web-version/13107998" target="_blank"  title="Get Mockup Studio">Get Mockup Studio</a>

</section>
<section id="home" class="home absolute-stretch">
    <div id="container" style="width: 100%;height: 100%">
        <canvas id="canvas_home"></canvas>
        <div class="quick-hint">Double Click on an element to change the design. <strong>It's just that easy!!</strong></div>
    </div>
</section>
<script id="shadowmap_pars_fragment" type="x-shader/x-fragment">


#ifdef USE_SHADOWMAP

	uniform sampler2D shadowMap[ MAX_SHADOWS ];
	uniform vec2 shadowMapSize[ MAX_SHADOWS ];

	uniform float shadowDarkness[ MAX_SHADOWS ];
	uniform float shadowBias[ MAX_SHADOWS ];
	uniform float shadowBlur[ MAX_SHADOWS ];

	varying vec4 vShadowCoord[ MAX_SHADOWS ];

	float unpackDepth( const in vec4 rgba_depth ) {

		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
		float depth = dot( rgba_depth, bit_shift );
		return depth;

	}

	#if defined(POINT_LIGHT_SHADOWS)


		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {

			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )
				shadowValue += 1.0;

		}


		vec2 cubeToUV( vec3 v, float texelSizeY ) {


			vec3 absV = abs( v );


			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
			absV *= scaleToCube;


			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );



			vec2 planar = v.xy;

			float almostATexel = 1.5 * texelSizeY;
			float almostOne = 1.0 - almostATexel;

			if ( absV.z >= almostOne ) {

				if ( v.z > 0.0 )
					planar.x = 4.0 - v.x;

			} else if ( absV.x >= almostOne ) {

				float signX = sign( v.x );
				planar.x = v.z * signX + 2.0 * signX;

			} else if ( absV.y >= almostOne ) {

				float signY = sign( v.y );
				planar.x = v.x + 2.0 * signY + 2.0;
				planar.y = v.z * signY - 2.0;

			}


			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

		}

	#endif

float texture2DCompare(sampler2D depths, vec2 uv, float compare){
    float depth = unpackDepth(texture2D(depths, uv));
    return step(compare, depth);
}

// Using similar triangles from the surface point to the area light
vec2 searchRegionRadiusUV(vec2 lightRadius, float lightZNear, float zWorld){
    return lightRadius * (zWorld - lightZNear) / zWorld;
}

// Using similar triangles between the area light, the blocking plane and the surface point
vec2 penumbraRadiusUV(vec2 lightRadius, float zReceiver, float zBlocker){
    return lightRadius * (zReceiver - zBlocker) / zBlocker;
}

// Project UV size to the near plane of the light
vec2 projectToLightUV(vec2 sizeUV, float lightZNear, float zWorld){
    return sizeUV * lightZNear / zWorld;
}

float biasedZ(float z0, vec2 dz_duv, vec2 offset){
    return z0 + dot(dz_duv, offset);
}

float PCSS(sampler2D shadowSampler, vec2 uv, float z, vec2 mapSize,float bias,float blur){

	float g_lightZNear = 25.0; //TODO: estimated
	float g_lightZFar = 2000.0;
	vec2 g_lightRadiusUV = vec2(0.5); //TODO: estimated
	vec2 poissonDisk[32];
	poissonDisk[0] = vec2(-0.975402, -0.0711386);
    poissonDisk[1] = vec2(-0.920347, -0.41142);
    poissonDisk[2] = vec2(-0.883908, 0.217872);
    poissonDisk[3] = vec2(-0.884518, 0.568041);
    poissonDisk[4] = vec2(-0.811945, 0.90521);
    poissonDisk[5] = vec2(-0.792474, -0.779962);
    poissonDisk[6] = vec2(-0.614856, 0.386578);
    poissonDisk[7] = vec2(-0.580859, -0.208777);
    poissonDisk[8] = vec2(-0.53795, 0.716666);
    poissonDisk[9] = vec2(-0.515427, 0.0899991);
    poissonDisk[10] = vec2(-0.454634, -0.707938);
    poissonDisk[11] = vec2(-0.420942, 0.991272);
    poissonDisk[12] = vec2(-0.261147, 0.588488);
    poissonDisk[13] = vec2(-0.211219, 0.114841);
    poissonDisk[14] = vec2(-0.146336, -0.259194);
    poissonDisk[15] = vec2(-0.139439, -0.888668);
    poissonDisk[16] = vec2(0.0116886, 0.326395);
    poissonDisk[17] = vec2(0.0380566, 0.625477);
    poissonDisk[18] = vec2(0.0625935, -0.50853);
    poissonDisk[19] = vec2(0.125584, 0.0469069);
    poissonDisk[20] = vec2(0.169469, -0.997253);
    poissonDisk[21] = vec2(0.320597, 0.291055);
    poissonDisk[22] = vec2(0.359172, -0.633717);
    poissonDisk[23] = vec2(0.435713, -0.250832);
    poissonDisk[24] = vec2(0.507797, -0.916562);
    poissonDisk[25] = vec2(0.545763, 0.730216);
    poissonDisk[26] = vec2(0.56859, 0.11655);
    poissonDisk[27] = vec2(0.743156, -0.505173);
    poissonDisk[28] = vec2(0.736442, -0.189734);
    poissonDisk[29] = vec2(0.843562, 0.357036);
    poissonDisk[30] = vec2(0.865413, 0.763726);
    poissonDisk[31] = vec2(0.872005, -0.927);

    float biasedZ = z+bias;
    vec2 searchRegionRadius = g_lightRadiusUV * 2.0 * (z - g_lightZNear) / z;//searchRegionRadiusUV(g_lightRadiusUV, g_lightZNear, z);

	float accumBlockerDepth = 0.0;
    float numBlockers = 0.0;
	float maxBlockers = 32.0;
	for (int i = 0; i < 32; i++)
	{
		vec2 offset = poissonDisk[i] * searchRegionRadius;
		float shadowMapDepth =  unpackDepth(texture2D(shadowSampler, uv + offset/mapSize));//borderDepthTexture(g_shadowMapDepth, uv + offset);

		if (shadowMapDepth < biasedZ)
		{
			accumBlockerDepth += shadowMapDepth;
			numBlockers++;
		}
	}


    // Early out if not in the penumbra
    if (numBlockers == 0.0)
        return 0.0;

        float avgBlockerDepth = accumBlockerDepth / numBlockers;
        float gap = (z-avgBlockerDepth);

    //float avgBlockerDepthWorld =  g_lightZFar * g_lightZNear / (g_lightZFar - avgBlockerDepth * (g_lightZFar - g_lightZNear));   //zClipToEye(avgBlockerDepth);
    vec2 penumbraRadius = g_lightRadiusUV * gap / avgBlockerDepth;//penumbraRadiusUV(g_lightRadiusUV, z, avgBlockerDepthWorld);
    vec2 filterRadius = 1000.0*penumbraRadius * g_lightZNear / z;//projectToLightUV(penumbraRadius, g_lightZNear, z);
	//filterRadius = vec2(max((z - avgBlockerDepth)*5000.0,2.0));

	float sum = 0.0;
float shadowBlur = max(1.0,blur);
filterRadius = vec2(max(filterRadius.x,shadowBlur),max(filterRadius.y,shadowBlur));
	for (int i = 0; i < 32; i++)
	{
		vec2 offset = poissonDisk[i] * filterRadius;

		sum += texture2DCompare(shadowSampler, uv  + offset/mapSize, biasedZ);//unpackDepth(texture2D(shadowSampler, uv + offset));//borderPCFTexture(g_shadowMapPcf, vec3(uv + offset, bz));
	}
	float pcf = sum / 32.0;

/*    vec4 rgbaDepth = texture2D( shadowSampler, uv);
float fDepth = unpackDepth( rgbaDepth );
float vsm = 0.0;
if ( fDepth < biasedZ)
{

float compare = biasedZ;
vec2 moments = rgbaDepth.xy;
float p = smoothstep(compare-2.02, compare, moments.x);
float variance =max(moments.y - moments.x*moments.x, -0.001);
float d = compare -moments.x;
float p_max = clamp((variance / (variance + d*d) - 0.2) / (1.0 - 0.2), 0.0, 1.0);
vsm = clamp(max(p, p_max),0.0, 1.0);
}

if((z - avgBlockerDepth)*10000.0<2.0)
{
    return max(vsm,1.0-pcf);
}
else
  */ return 1.0-pcf;

	//vsm
	//return max(pcf,vsm);
}

float PCSS2(sampler2D shadowSampler, vec2 uv, float zReceiver, vec2 mapSize,float bias){

	float NEAR_PLANE = 25.0; //TODO: estimated
	float LIGHT_WORLD_SIZE = 1.0;
	float LIGHT_FRUSTUM_WIDTH = 3.75;
	float LIGHT_SIZE_UV = LIGHT_WORLD_SIZE/LIGHT_FRUSTUM_WIDTH;

	vec2 poissonDisk[32];
	poissonDisk[0] = vec2(-0.975402, -0.0711386);
    poissonDisk[1] = vec2(-0.920347, -0.41142);
    poissonDisk[2] = vec2(-0.883908, 0.217872);
    poissonDisk[3] = vec2(-0.884518, 0.568041);
    poissonDisk[4] = vec2(-0.811945, 0.90521);
    poissonDisk[5] = vec2(-0.792474, -0.779962);
    poissonDisk[6] = vec2(-0.614856, 0.386578);
    poissonDisk[7] = vec2(-0.580859, -0.208777);
    poissonDisk[8] = vec2(-0.53795, 0.716666);
    poissonDisk[9] = vec2(-0.515427, 0.0899991);
    poissonDisk[10] = vec2(-0.454634, -0.707938);
    poissonDisk[11] = vec2(-0.420942, 0.991272);
    poissonDisk[12] = vec2(-0.261147, 0.588488);
    poissonDisk[13] = vec2(-0.211219, 0.114841);
    poissonDisk[14] = vec2(-0.146336, -0.259194);
    poissonDisk[15] = vec2(-0.139439, -0.888668);
    poissonDisk[16] = vec2(0.0116886, 0.326395);
    poissonDisk[17] = vec2(0.0380566, 0.625477);
    poissonDisk[18] = vec2(0.0625935, -0.50853);
    poissonDisk[19] = vec2(0.125584, 0.0469069);
    poissonDisk[20] = vec2(0.169469, -0.997253);
    poissonDisk[21] = vec2(0.320597, 0.291055);
    poissonDisk[22] = vec2(0.359172, -0.633717);
    poissonDisk[23] = vec2(0.435713, -0.250832);
    poissonDisk[24] = vec2(0.507797, -0.916562);
    poissonDisk[25] = vec2(0.545763, 0.730216);
    poissonDisk[26] = vec2(0.56859, 0.11655);
    poissonDisk[27] = vec2(0.743156, -0.505173);
    poissonDisk[28] = vec2(0.736442, -0.189734);
    poissonDisk[29] = vec2(0.843562, 0.357036);
    poissonDisk[30] = vec2(0.865413, 0.763726);
    poissonDisk[31] = vec2(0.872005, -0.927);

    float searchWidth = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;

//    vec2 searchRegionRadius = g_lightRadiusUV * (z - g_lightZNear) / z;//searchRegionRadiusUV(g_lightRadiusUV, g_lightZNear, z);

	float accumBlockerDepth = 0.0;
    float numBlockers = 0.0;
	float maxBlockers = 32.0;
	for (int i = 0; i < 32; i++)
	{
		vec2 offset = poissonDisk[i] * searchWidth;
		float shadowMapDepth =  unpackDepth(texture2D(shadowSampler, uv + offset/mapSize));//borderDepthTexture(g_shadowMapDepth, uv + offset);
		float bz = zReceiver+bias;//biasedZ(z, dz_duv, offset);
		if (shadowMapDepth < bz)
		{
			accumBlockerDepth += shadowMapDepth;
			numBlockers++;
		}
	}

    //return numBlockers/maxBlockers;
    // Early out if not in the penumbra
    if (numBlockers == 0.0)
        return 0.0;

    float avgBlockerDepth = accumBlockerDepth / numBlockers; //return  (zReceiver - avgBlockerDepth)*100.0;

    float penumbraRatio = (zReceiver - avgBlockerDepth) / avgBlockerDepth;//PenumbraSize(zReceiver, avgBlockerDepth);
    float filterRadiusUV = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;
    //return 1.0-filterRadiusUV;
    //float avgBlockerDepthWorld =  g_lightZFar * g_lightZNear / (g_lightZFar - avgBlockerDepth * (g_lightZFar - g_lightZNear));   //zClipToEye(avgBlockerDepth);
    //vec2 penumbraRadius = g_lightRadiusUV * (zReceiver - avgBlockerDepthWorld) / avgBlockerDepthWorld;//penumbraRadiusUV(g_lightRadiusUV, z, avgBlockerDepthWorld);
    //vec2 filterRadius = penumbraRadius * g_lightZNear / z;//projectToLightUV(penumbraRadius, g_lightZNear, z);
	//filterRadius = vec2(max((zReceiver - avgBlockerDepth)*5000.0,2.0));

	float sum = 0.0;
    //vec2 filterRadius = vec2(filterRadiusUV);
	for (int i = 0; i < 32; i++)
	{
		//vec2 offset = vec2((i-18.0)/32.) * filterRadiusUV*100.0;
		vec2 offset = poissonDisk[i]* filterRadiusUV*20.0;
		float bz = zReceiver+bias;//biasedZ(z, dz_duv, offset);
		sum += texture2DCompare(shadowSampler, uv  + offset/mapSize, bz);//unpackDepth(texture2D(shadowSampler, uv + offset));//borderPCFTexture(g_shadowMapPcf, vec3(uv + offset, bz));
	}
	float pcf = sum / 32.0;

        return 1.0-pcf;
	//vsm
	//return max(pcf,vsm);

}

#endif


</script>
<script id="shadowmap_fragment" type="x-shader/x-fragment">
#ifdef USE_SHADOWMAP

	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {

		float texelSizeY =  1.0 / shadowMapSize[ i ].y;

		float shadow = 0.0;

#if defined( POINT_LIGHT_SHADOWS )

		bool isPointLight = shadowDarkness[ i ] < 0.0;

		if ( isPointLight ) {

			float realShadowDarkness = abs( shadowDarkness[ i ] );

			vec3 lightToPosition = vShadowCoord[ i ].xyz;

	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec3 bd3D = normalize( lightToPosition );
			float dp = length( lightToPosition );

			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );


	#if defined( SHADOWMAP_TYPE_PCF )
			const float Dr = 1.25;
	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			const float Dr = 2.25;
	#endif

			float os = Dr *  2.0 * texelSizeY;

			const vec3 Gsd = vec3( - 1, 0, 1 );

			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );

			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );
			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );

			shadow *= realShadowDarkness * ( 1.0 / 21.0 );

	#else
			vec3 bd3D = normalize( lightToPosition );
			float dp = length( lightToPosition );

			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );

			shadow *= realShadowDarkness;

	#endif

		} else {

#endif
			float texelSizeX =  1.0 / shadowMapSize[ i ].x;

			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;


			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
			bool inFrustum = all( inFrustumVec );

			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

			bool frustumTest = all( frustumTestVec );

			if ( frustumTest ) {

	#if defined( SHADOWMAP_TYPE_PCF )


				/*
					for ( float y = -1.25; y <= 1.25; y += 1.25 )
						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {
							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );
							float fDepth = unpackDepth( rgbaDepth );
							if ( fDepth < shadowCoord.z )
								shadow += 1.0;
					}
					shadow /= 9.0;
				*/

				shadowCoord.z += shadowBias[ i ];

				const float ShadowDelta = 1.0 / 9.0;

				float xPixelOffset = texelSizeX;
				float yPixelOffset = texelSizeY;

				float dx0 = - 1.25 * xPixelOffset;
				float dy0 = - 1.25 * yPixelOffset;
				float dx1 = 1.25 * xPixelOffset;
				float dy1 = 1.25 * yPixelOffset;

				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );
				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;

				shadow *= shadowDarkness[ i ];

	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )


				//shadowCoord.z += shadowBias[ i ];

				/*float xPixelOffset = texelSizeX;
				float yPixelOffset = texelSizeY;

				float dx0 = - 1.0 * xPixelOffset;
				float dy0 = - 1.0 * yPixelOffset;
				float dx1 = 1.0 * xPixelOffset;
				float dy1 = 1.0 * yPixelOffset;

				mat3 shadowKernel;
				mat3 depthKernel;

				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );
				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );
				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );
				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );
				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );
				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );
				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );
				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );
				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );

				vec3 shadowZ = vec3( shadowCoord.z );
				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );
				shadowKernel[ 0 ] *= vec3( 0.25 );

				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );
				shadowKernel[ 1 ] *= vec3( 0.25 );

				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );
				shadowKernel[ 2 ] *= vec3( 0.25 );

				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );

				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );
				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );

				vec4 shadowValues;
				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );
				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );
				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );
				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );

				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];*/


				shadow = PCSS(shadowMap[ i ],shadowCoord.xy,shadowCoord.z, shadowMapSize[i], shadowBias[ i ], shadowBlur[ i ]);

				shadow *= shadowDarkness[ i ];

	#else
				shadowCoord.z += shadowBias[ i ];

				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );
				float fDepth = unpackDepth( rgbaDepth );

				if ( fDepth < shadowCoord.z )
					shadow = shadowDarkness[ i ];

	#endif

			}

#ifdef SHADOWMAP_DEBUG

			if ( inFrustum ) {

				if ( i == 0 ) {

					outgoingLight *= vec3( 1.0, 0.5, 0.0 );

				} else if ( i == 1 ) {

					outgoingLight *= vec3( 0.0, 1.0, 0.8 );

				} else {

					outgoingLight *= vec3( 0.0, 0.5, 1.0 );

				}

			}

#endif

#if defined( POINT_LIGHT_SHADOWS )

		}

#endif

		shadowMask = shadowMask * vec3( 1.0 - shadow );

	}

#endif

</script>

<script src="js/libs/Three.pre.js"></script>
<script src="js/libs/Dexie.js"></script>
<script src="js/libs/Detector.js"></script>
<script src="js/libs/jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="js/libs/sweetalert.min.js"></script>

<script src="js/main.min.js"></script>
<script src="js/main.js"></script>

<script type="text/javascript" src="js/libs/dat.gui.min.js"></script>

<script src="js/libs/three.js"></script>
<script src="js/libs/NURBS.js"></script>

<script src="js/libs/Three.extra.js"></script>
<script src="js/libs/threex.universalloader.js"></script>

<script src="js/libs/OBJLoader.js"></script>
<script src="js/libs/MTLLoader.js"></script>
<script src="js/libs/OBJMTLLoader.js"></script>
<script src="js/libs/extra.js"></script>
<script src="js/libs/stats.min.js"></script>

<!--<script src="js/libs/mockup.min.js"></script>-->
<script src="js/libs/mockup.js"></script>

<script src="js/editor.min.js"></script>
<script src="js/editor.js"></script>

<script src="js/libs/fileSystem.min.js"></script>
<script src="js/libs/fileSystem.js"></script>

<script src="js/mockup-presets.js" type="text/javascript"></script>
<div class="g-signin2" data-onsuccess="onSignIn"></div>
</body>
</html>

